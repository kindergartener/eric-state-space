<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="http://ericstate.space/global.css">

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"
    integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6"
    crossorigin="anonymous"></script>
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  
  

  <title>eric state space</title>
</head>

<body>
    <header class="header">
       

      
        
  
  
    

    
      
      
      
      
      
      
      
      
      
      
      
      

    
      
      
    
    
    
  

  <nav class="menu">
    <ul class="menu-inner">
    
      <li class="menu-item  active ">
        <a href="http://ericstate.space">blog</a>
      </li>
    
      <li class="menu-item ">
        <a href="http://ericstate.space/tags">tags</a>
      </li>
    
      <li class="menu-item ">
        <a href="http://ericstate.space/experiments">experiments</a>
      </li>
    
      <li class="menu-item ">
        <a href="http://ericstate.space/archive">archive</a>
      </li>
    
    </ul>
  </nav>  

  

      
    </header>

    <div class="container-inner 
  container-inner-blog
">
      <div class="content">
        
  <div class="layout-blog">
    <aside class="layout-left">
      

    
  
    
    <nav class="toc" id="toc-fibonacci" aria-label="Table of contents">
      <div class="toc-title">Contents</div>
      <ol class="toc-list" data-toc-root>
        <li class="toc-item"><a class="toc-link" href="#"><span class="toc-text">(Top)</span></a></li>
        
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#the-naive-approach"
         data-target="the-naive-approach">
        <span class="toc-text">The Naïve Approach</span>
      </a>

      
    </li>
  
    

    <li class="toc-item has-children is-open">
      
        <button class="toc-toggle"
                type="button"
                aria-label="Toggle Sliding Window"
                aria-expanded="true"
                data-toc-toggle>
          <span class="toc-caret" aria-hidden="true">›</span>
        </button>
      

      <a class="toc-link"
         href="#sliding-window"
         data-target="sliding-window">
        <span class="toc-text">Sliding Window</span>
      </a>

      
        <ol class="toc-list">
          
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#big-integers"
         data-target="big-integers">
        <span class="toc-text">Big Integers</span>
      </a>

      
    </li>
  

        </ol>
      
    </li>
  
    

    <li class="toc-item has-children is-open">
      
        <button class="toc-toggle"
                type="button"
                aria-label="Toggle Matrix Multiplication"
                aria-expanded="true"
                data-toc-toggle>
          <span class="toc-caret" aria-hidden="true">›</span>
        </button>
      

      <a class="toc-link"
         href="#matrix-multiplication"
         data-target="matrix-multiplication">
        <span class="toc-text">Matrix Multiplication</span>
      </a>

      
        <ol class="toc-list">
          
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#binary-exponentiation"
         data-target="binary-exponentiation">
        <span class="toc-text">Binary Exponentiation</span>
      </a>

      
    </li>
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#heap"
         data-target="heap">
        <span class="toc-text">Heap</span>
      </a>

      
    </li>
  

        </ol>
      
    </li>
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#fast-doubling"
         data-target="fast-doubling">
        <span class="toc-text">Fast Doubling</span>
      </a>

      
    </li>
  
    

    <li class="toc-item">
      
        <span class="toc-spacer" aria-hidden="true"></span>
      

      <a class="toc-link"
         href="#discussion"
         data-target="discussion">
        <span class="toc-text">Discussion</span>
      </a>

      
    </li>
  

      </ol>
    </nav>

    
  
  <script>

  document.addEventListener("DOMContentLoaded", () => {
    const toc = document.getElementById("toc-fibonacci");
    if (!toc) return;

    // --- Collapse/expand (event delegation) ---
    toc.addEventListener("click", (e) => {
      const btn = e.target.closest(".toc-toggle");
      if (!btn || !toc.contains(btn)) return;

      const li = btn.closest(".toc-item");
      if (!li) return;

      const open = li.classList.toggle("is-open");
      btn.setAttribute("aria-expanded", open ? "true" : "false");

      e.stopPropagation();
    });

    // --- Scrollspy (your simple version, with ancestor opening) ---
    const tocLinks = toc.querySelectorAll(".toc a[href^='#']");
    const headings = Array.from(tocLinks)
      .map((a) => document.getElementById(a.getAttribute("href").slice(1)))
      .filter(Boolean);

    if (headings.length === 0) return;

    const clearActive = () => {
      toc.querySelectorAll(".is-active").forEach((n) => n.classList.remove("is-active"));
    };

    function openAncestors(a) {
      let li = a.closest("li.toc-item");
      while (li) {
        li.classList.add("is-open");
        const btn = li.querySelector(":scope > .toc-toggle");
        if (btn) {
          btn.setAttribute("aria-expanded", "true");
        }
        li = li.parentElement?.closest("li.toc-item");
      }
    }

    function activateById(id) {
      clearActive();
      if (!id) return;
      const a = toc.querySelector(`.toc a[href="#${CSS.escape(id)}"]`);
      if (!a) return;
      a.classList.add("is-active");
      openAncestors(a);
    }

    let ticking = false;
    function updateActiveLink() {
      ticking = false;
      const triggerLine = window.innerHeight * 0.25; // 25% from top
      let current = null;

      // pick the LAST heading above the trigger line
      for (let i = headings.length - 1; i >= 0; i--) {
        const rect = headings[i].getBoundingClientRect();
        if (rect.top <= triggerLine) { current = headings[i]; break; }
      }

      activateById(current ? current.id : null);
    }

    window.addEventListener("scroll", () => {
      if (!ticking) {
        ticking = true;
        requestAnimationFrame(updateActiveLink);
      }
    }, { passive: true });

    window.addEventListener("resize", updateActiveLink);
    window.addEventListener("load", updateActiveLink);

    // hash navigation support
    window.addEventListener("hashchange", () => {
      activateById(decodeURIComponent(location.hash.slice(1)));
    });

    // initial
    updateActiveLink();
    if (location.hash) activateById(decodeURIComponent(location.hash.slice(1)));
  });
</script>



    </aside>

    <main class="content">
      

  <header class="post-header">
    <h1 class="post-title">Fibonacci Numbers in Rust</h1>

    <div class="post-meta-inline">
      
      
        <span class="post-date">
          2025-07-26
        </span>
      

      

      
      
        <span class="post-reading-time">: : 11 min read</span>
      

      

      
      
        <span class="post-tags-inline">
          : : 
          
            <a class="post-tag" href="http://ericstate.space/tags/math/">#math</a> 
          
            <a class="post-tag" href="http://ericstate.space/tags/numerical-computation/">#numerical-computation</a> 
          
            <a class="post-tag" href="http://ericstate.space/tags/performance/">#performance</a> 
          
            <a class="post-tag" href="http://ericstate.space/tags/rust/">#rust</a>
          
        </span>
      

  </header>

  <div class="post-content">
    <p>Perhaps one of the most well-known numeric sequences, the Fibonacci sequence sees each number as the sum of the two
preceding numbers. Starting with \(0\) and \(1\), we can find the next element by doing \(0 + 1 = 1\), then \(1 + 1 = 2\) and
so on. The first 10 Fibonacci numbers are \(0, 1, 1, 2, 3, 5, 8, 13, 21, 34\). The Fibonacci sequence
can be defined by the recurrence relation:</p>
<p>$$
\begin{aligned}
\mathrm{F_1} &amp;= 0 , \mathrm{F_2} = 1 \newline
\mathrm{F_n} &amp;= \mathrm{F_{n-1}} + \mathrm{F_{n-2}}
\end{aligned}
$$</p>
<p>On an unrelated note, I started learning the Rust programming language last year. While reading about the Fibonacci numbers, I started thinking to myself,
"Hey, I should write a Rust program to generate these!" But that begs the question, how fast can I calculate these Fibonacci numbers?
Can Rust provide me any unique benefits towards this goal? In this exploration, I try to calculate the largest Fibonacci number possible in under
1 second, in Rust.</p>
<h1 id="the-naive-approach">The Naïve Approach</h1>
<p>The obvious way to calculate Fibonacci numbers in Rust would be to directly translate the recurrence relation above--in
other words, the recursive approach. The code for this is pretty simple actually:</p>
<pre data-lang="rust" style="background-color:#383838;color:#e6e1dc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_recursive</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">u128 </span><span>{
</span><span>    </span><span style="color:#cc7833;">match</span><span> n {
</span><span>        </span><span style="color:#a5c261;">0 </span><span style="color:#cc7833;">=&gt; </span><span style="color:#a5c261;">0</span><span>,
</span><span>        </span><span style="color:#a5c261;">1 </span><span style="color:#cc7833;">=&gt; </span><span style="color:#a5c261;">1</span><span>,
</span><span>        </span><span style="color:#cc7833;">_ =&gt; </span><span style="color:#da4939;">fib_recursive</span><span>(n</span><span style="color:#cc7833;">-</span><span style="color:#a5c261;">1</span><span>) </span><span style="color:#cc7833;">+ </span><span style="color:#da4939;">fib_recursive</span><span>(n</span><span style="color:#cc7833;">-</span><span style="color:#a5c261;">2</span><span>),
</span><span>    }
</span><span>}
</span></code></pre>
<p>Simple, but not really practical. This algorithm has exponential time complexity, let's call it \(O(2^n)\).
The runtime graph below is pretty pitiful, as we can only calculate the 38th Fibonacci number this way. I could do that with
a pen, paper, and a free afternoon!</p>
<figure>
  <img src="/images/fibonacci_recursive.png" alt="Recursive Fibonacci" />
  <figcaption>
    Runtime graph for recursive Fibonacci with max_n = 38.
  </figcaption>
</figure>
<h1 id="sliding-window">Sliding Window</h1>
<p>This next algorithm is a substantial improvement over the last and one of the most commonly
used Fibonacci algorithms.</p>
<pre data-lang="rust" style="background-color:#383838;color:#e6e1dc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_slidingwin</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; </span><span style="font-style:italic;color:#6e9cbe;">u128 </span><span>{
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let </span><span>(</span><span style="color:#cc7833;">mut</span><span> a, </span><span style="color:#cc7833;">mut</span><span> b) </span><span style="color:#cc7833;">= </span><span>(</span><span style="color:#a5c261;">0</span><span>, </span><span style="color:#a5c261;">1</span><span>);
</span><span>    </span><span style="color:#cc7833;">for _ in </span><span style="color:#a5c261;">0</span><span style="color:#cc7833;">..</span><span>n {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> t </span><span style="color:#cc7833;">=</span><span> a </span><span style="color:#cc7833;">+ &amp;</span><span>b;
</span><span>        (a, b) </span><span style="color:#cc7833;">= </span><span>(b, t);
</span><span>    }
</span><span>    a
</span><span>}
</span></code></pre>
<p>This algorithm runs in linear time, \(O(n)\). We quickly run into an issue though; the maximum
value a <code>u128</code> integer type can hold is \(2^{128} - 1 \approx 3.40 \times 10^{38}\). The largest
Fibonacci number within this bound is \(\mathrm{F_{186}} \approx 3.33 \times 10^{38}\), so we won't be
able to calculate any terms after 186. We must use a type that can handle arbitrarily large integers.</p>
<h2 id="big-integers">Big Integers</h2>
<p>I use the <a href="https://docs.rs/num-bigint/latest/num_bigint/">num_bigint</a> crate
which gives us the type <code>BigUint</code>, a vector of digits. The capacity of this type is still limited
by the underlying allocator and operating system, but it should be enough to store any
Fibonacci number we need.</p>
<p>Implementing this with the example above we get:</p>
<pre data-lang="rust" style="background-color:#383838;color:#e6e1dc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_slidingwin</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; BigUint {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let </span><span>(</span><span style="color:#cc7833;">mut</span><span> a, </span><span style="color:#cc7833;">mut</span><span> b) </span><span style="color:#cc7833;">= </span><span>(BigUint::zero(), BigUint::one());
</span><span>    </span><span style="color:#cc7833;">for _ in </span><span style="color:#a5c261;">0</span><span style="color:#cc7833;">..</span><span>n {
</span><span>        </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> t </span><span style="color:#cc7833;">=</span><span> a </span><span style="color:#cc7833;">+ &amp;</span><span>b;
</span><span>        (a, b) </span><span style="color:#cc7833;">= </span><span>(b, t);
</span><span>    }
</span><span>    a
</span><span>}
</span></code></pre>
<p>Let's see what the runtime graph looks like:</p>
<figure>
  <img src="/images/fibonacci_sliding-window.png" alt="Sliding Window Fibonacci" />
  <figcaption>
    Runtime graph for sliding window Fibonacci with max_n = 694,720.
  </figcaption>
</figure>
<h1 id="matrix-multiplication">Matrix Multiplication</h1>
<p>This next algorithm makes use of a lesser-known matrix identity for the Fibonacci numbers.
Start with the observation that:</p>
<p>$$
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
1 \newline
1
\end{bmatrix}
=
\begin{bmatrix}
2 \newline
1
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
2 \newline
1
\end{bmatrix}
=
\begin{bmatrix}
3 \newline
2
\end{bmatrix} \newline
\dots
$$</p>
<p>In general, the square matrix \(\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}
\) sends \(\begin{bmatrix} \mathrm{F_{n}} \ \mathrm{F_{n-1}} \end{bmatrix}\)
to the "next" vector \(\begin{bmatrix} \mathrm{F_{n+1}} \ \mathrm{F_{n}} \end{bmatrix}\):</p>
<p>$$
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
\mathrm{F_{n}} \newline
\mathrm{F_{n-1}}
\end{bmatrix}
=
\begin{bmatrix}
\mathrm{F_{n}} + \mathrm{F_{n-1}} \newline
\mathrm{F_{n}}
\end{bmatrix}
=
\begin{bmatrix}
\mathrm{F_{n+1}} \newline
\mathrm{F_{n}}
\end{bmatrix}
$$</p>
<p>Using similar logic and the magic of induction, one can show that the square matrix "generates" Fibonacci numbers:</p>
<p>$$
\boxed{
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
^{n}
=
\begin{bmatrix}
\mathrm{F_{n+1}} &amp; \mathrm{F_{n}} \newline
\mathrm{F_{n}} &amp; \mathrm{F_{n-1}}
\end{bmatrix}
}
$$</p>
<p>This is the formula I used for my Fibonacci algorithm! If we can multiply \(n\) matrices, we can
get the \(n+1\) Fibonacci number. In theory this has \(O(n)\) runtime complexity
since we perform an \(O(1)\) matrix multiplication $n$ times, but we can do better.</p>
<h2 id="binary-exponentiation">Binary Exponentiation</h2>
<p>Binary exponentiation or <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">exponentiating by squaring</a>
is a method to calculate integer powers of a number in \(\lceil \log_2 n \rceil\) multiplications
instead of \(n\). We start by writing the exponent in binary as such:</p>
<p>$$
\begin{aligned}
3^{11} &amp; = 3^{1011_2} \newline
&amp; = 3^8 \cdot 3^2 \cdot 3^1 \newline
&amp; = 6561 \cdot 9 \cdot 3 \newline
&amp; = 177147
\end{aligned}
$$</p>
<p>The key realization here is that we can get \(3^2\) by squaring \(3^1\) and
\(3^8\) by squaring \(3^2\) twice. In this way, we can "build up" to our answer
by squaring each term for the next power of two:</p>
<p>$$
x^n =
\begin{cases}
(x^\frac{n}{2})^2 &amp; \text{if } x \text{ is even} \newline
x \cdot (x^\frac{n-1}{2})^2 &amp; \text{if } x \text{ is odd}
\end{cases}
$$</p>
<p>We can recurse on \(x^\frac{n}{2}\) or \(x^\frac{n-1}{2}\) until we get to \(n=1\), at which point we stop.
So the complexity is \(O(\log n)\): we compute \(\log n\) powers of \(x\) and do at most \(\log n\) multiplications.</p>
<p>I use an iterative version of this algorithm with the above Fibonacci matrix identity to compute
Fibonacci numbers in \(O(\log n)\) time. Here's how it's done:</p>
<pre data-lang="rust" style="background-color:#383838;color:#e6e1dc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#95815e;">/// Calculates A^n where A is a 2x2 matrix and n &gt;= 0
</span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">matrix_pow</span><span>(</span><span style="color:#cc7833;">mut </span><span style="font-style:italic;color:#fd971f;">a</span><span>: [[BigUint; 2]; 2], </span><span style="color:#cc7833;">mut </span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; [[BigUint; </span><span style="color:#a5c261;">2</span><span>]; </span><span style="color:#a5c261;">2</span><span>] {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let </span><span style="color:#cc7833;">mut</span><span> res </span><span style="color:#cc7833;">= </span><span>[
</span><span>        [BigUint::one(), BigUint::zero()],
</span><span>        [BigUint::zero(), BigUint::one()],
</span><span>    ];
</span><span>    </span><span style="color:#cc7833;">while</span><span> n </span><span style="color:#cc7833;">&gt; </span><span style="color:#a5c261;">0 </span><span>{
</span><span>        </span><span style="color:#cc7833;">if </span><span>(n </span><span style="color:#cc7833;">&amp; </span><span style="color:#a5c261;">1</span><span>) </span><span style="color:#cc7833;">== </span><span style="color:#a5c261;">1 </span><span>{
</span><span>            res </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">matrix_mult</span><span>(</span><span style="color:#cc7833;">&amp;</span><span>res, </span><span style="color:#cc7833;">&amp;</span><span>a);
</span><span>        }
</span><span>        a </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">matrix_mult</span><span>(</span><span style="color:#cc7833;">&amp;</span><span>a, </span><span style="color:#cc7833;">&amp;</span><span>a);
</span><span>        n </span><span style="color:#cc7833;">&gt;&gt;= </span><span style="color:#a5c261;">1</span><span>;
</span><span>    }
</span><span>    res
</span><span>}
</span><span>
</span><span style="color:#95815e;">/// Entry point
</span><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_matrixmult</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; BigUint {
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> f </span><span style="color:#cc7833;">= </span><span>[
</span><span>        [BigUint::one(), BigUint::one()],
</span><span>        [BigUint::one(), BigUint::zero()],
</span><span>    ];
</span><span>
</span><span>    </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> fib_n </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">matrix_pow</span><span>(f, n </span><span style="color:#cc7833;">- </span><span style="color:#a5c261;">1</span><span>);
</span><span>
</span><span>    fib_n[</span><span style="color:#a5c261;">0</span><span>][</span><span style="color:#a5c261;">0</span><span>].</span><span style="color:#da4939;">clone</span><span>()
</span><span>}
</span></code></pre>
<p>Here <code>matrix_mult</code> is a function that multiplies 2x2 matrices. Looking at the graph,
we achieve a significant improvement over the sliding window method, with a maximum
iteration of \(n=4,370,432\):</p>
<figure>
  <img class="center" src="/images/fibonacci_matrix-mult.png" alt="Matrix Multiplication Fibonacci" />
  <figcaption>
    Runtime graph for matrix multiplication Fibonacci with max_n = 4,370,432.
  </figcaption>
</figure>
<p>Wait, why does this look more like a staircase than a slide? Something's going on here.</p>
<h2 id="heap">Heap</h2>
<p>There's something nonlinear happening here. We see these discrete runtime spikes occurring at around \(n\approx1\mathrm{e}6\),
\(2\mathrm{e}6\), and \(4\mathrm{e}6\). These threshold-based jumps suggest something about the way <code>BigUint</code> handles large numbers.</p>
<p>Internally, the type is a dynamically sized <code>Vec&lt;usize&gt;</code>; when the number of bits (digits) exceeds a power of 2, the buffer
must <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#capacity-and-reallocation">reallocate its maximum capacity</a>. This reallocation involves expensive operations like heap allocation and copying old digits.</p>
<p>In essence, the cost per step depends on the current size of <code>BigUint</code>: once
\(\mathrm{F_n}\) reaches a new order of magnitude, each multiplication gets more expensive.</p>
<p>It's worth mentioning the <code>.clone()</code> method used to return our Fibonacci number. <code>BigUint</code> does not implement the <code>Copy</code> trait, so
we can't just <a href="https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html">move the value</a> out the matrix. For large \(n\), cloning could bottleneck performance, although I couldn't find a way to avoid it.</p>
<h1 id="fast-doubling">Fast Doubling</h1>
<p>The fast doubling approach makes use of the "double-angle" identities for the Fibonacci numbers. We can arrive at
these identities by simply squaring the matrix representation:</p>
<p>$$
\begin{aligned}
\begin{bmatrix}
\mathrm{F_{2n+1}} &amp; \mathrm{F_{2n}} \newline
\mathrm{F_{2n}} &amp; \mathrm{F_{2n-1}}
\end{bmatrix}
&amp; =
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
^{2n} \newline \newline
&amp; =
\left(
\begin{bmatrix}
1 &amp; 1 \newline
1 &amp; 0
\end{bmatrix}
^{n}
\right)
^{2} \newline \newline
&amp; =
\left(
\begin{bmatrix}
\mathrm{F_{n+1}} &amp; \mathrm{F_{n}} \newline
\mathrm{F_{n}} &amp; \mathrm{F_{n-1}}
\end{bmatrix}
\right)
^{2} \newline \newline
&amp; =
\begin{bmatrix}
\mathrm{F_{n+1}^{2} + F_{n}^{2}} &amp; \mathrm{F_{n}(F_{n+1} + F_{n-1})} \newline
\mathrm{F_{n}(F_{n+1} + F_{n-1})} &amp; \mathrm{F_{n}^{2} + F_{n-1}^{2}}
\end{bmatrix}
\end{aligned}
$$</p>
<p>Note that \(\mathrm{F_{n}(F_{n+1} + F_{n-1})}\) can be written as \(\mathrm{F_{n}(2F_{n+1} - F_{n})}\) using
\(\mathrm{F_{n-1} = F_{n+1} - F_{n}}\). Finally, we equate the terms in corresponding matrix entries to get
the doubling identities:</p>
<p>$$
\boxed{
\begin{aligned}
\mathrm{F_{2n+1}} &amp; = \mathrm{F_{n+1}^{2} + F_{n}^{2}} \newline
\mathrm{F_{2n}} &amp; = \mathrm{F_{n}(2F_{n+1} - F_{n})}
\end{aligned}
}
$$</p>
<p>We can use these identities to compute \((\mathrm{F_{n}}, \mathrm{F_{n+1}})\) by recursing on \(\lfloor n/2 \rfloor\), which gives
a \(O(\log n)\) recursion depth.
Given \((a, b) = (\mathrm{F_{\lfloor n/2 \rfloor}}, \mathrm{F_{\lfloor n/2 \rfloor +1}})\), let</p>
<p>$$
\begin{aligned}
c &amp;= a(2b - a) \newline
d &amp;= a^2 + b^2
\end{aligned}
$$</p>
<p>Our desired Fibonacci numbers are</p>
<p>$$
(\mathrm{F_{n}}, \mathrm{F_{n+1}}) =
\begin{cases}
(c, d) &amp; \text{if } n \text{ is even} \newline
(d, c + d) &amp; \text{if } n \text{ is odd}
\end{cases}
$$</p>
<p>and we can implement this as follows:</p>
<pre data-lang="rust" style="background-color:#383838;color:#e6e1dc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#95815e;">/// Returns (F(n), F(n+1))
</span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_doubling_recursive</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; (BigUint, BigUint) {
</span><span>    </span><span style="color:#cc7833;">match</span><span> n {
</span><span>        </span><span style="color:#a5c261;">0 </span><span style="color:#cc7833;">=&gt; </span><span>(BigUint::zero(), BigUint::one()),
</span><span>        </span><span style="color:#cc7833;">_ =&gt; </span><span>{
</span><span>            </span><span style="color:#95815e;">// a := F(n), b := F(n+1)
</span><span>            </span><span style="color:#95815e;">// We recurse on floor(n/2)
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let </span><span>(a, b) </span><span style="color:#cc7833;">= </span><span style="color:#da4939;">fib_doubling_recursive</span><span>(n </span><span style="color:#cc7833;">&gt;&gt; </span><span style="color:#a5c261;">1</span><span>);
</span><span>
</span><span>            </span><span style="color:#95815e;">// c := F(2n)   = F(n) * (2*F(n+1) - F(n))
</span><span>            </span><span style="color:#95815e;">// d := F(2n+1) = F(n)^2 + F(n+1)^2
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> t </span><span style="color:#cc7833;">= </span><span>(</span><span style="color:#cc7833;">&amp;</span><span>b </span><span style="color:#cc7833;">&lt;&lt; </span><span style="color:#a5c261;">1</span><span>) </span><span style="color:#cc7833;">- &amp;</span><span>a;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> c </span><span style="color:#cc7833;">= &amp;</span><span>a </span><span style="color:#cc7833;">* &amp;</span><span>t;
</span><span>            </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> d </span><span style="color:#cc7833;">= &amp;</span><span>a </span><span style="color:#cc7833;">* &amp;</span><span>a </span><span style="color:#cc7833;">+ &amp;</span><span>b </span><span style="color:#cc7833;">* &amp;</span><span>b;
</span><span>
</span><span>            </span><span style="color:#cc7833;">match</span><span> n </span><span style="color:#cc7833;">&amp; </span><span style="color:#a5c261;">1 </span><span>{
</span><span>                </span><span style="color:#a5c261;">0 </span><span style="color:#cc7833;">=&gt; </span><span>(c, d), </span><span style="color:#95815e;">// Even: F(n) = c, F(n+1) = d
</span><span>                </span><span style="color:#cc7833;">_ =&gt; </span><span>{
</span><span>                    </span><span style="color:#95815e;">// Odd:  F(n) = d, F(n+1) = c + d
</span><span>                    </span><span style="font-style:italic;color:#6e9cbe;">let</span><span> sum </span><span style="color:#cc7833;">= &amp;</span><span>c </span><span style="color:#cc7833;">+ &amp;</span><span>d;
</span><span>                    (d, sum)
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#95815e;">/// Entry point
</span><span style="color:#cc7833;">pub </span><span style="font-style:italic;color:#6e9cbe;">fn </span><span style="color:#ffc66d;">fib_doubling</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>: </span><span style="font-style:italic;color:#6e9cbe;">usize</span><span>) -&gt; BigUint {
</span><span>    </span><span style="color:#da4939;">fib_doubling_recursive</span><span>(n).</span><span style="color:#a5c261;">0
</span><span>}
</span></code></pre>
<p>This algorithm is a significant improvement over Matrix Multiplication, achieving a maximum iteration of
\(n = 17,937,917\):</p>
<figure>
  <img src="/images/fibonacci_doubling.png" alt="Fast Doubling Fibonacci" />
  <figcaption>
    Runtime graph for fast doubling Fibonacci with max_n = 17,937,917.
  </figcaption>
</figure>
<p>The main thing to note is that this process involves just 3 <code>BigUint</code> multiplications: one for calculating \(c\) and two for
\(d\). Compare this to the 8-12 <code>BigUint</code> multiplications required for the Matrix Multiplication method and we can see why Fast Doubling
is able to calculate such large numbers, despite both algorithms being \(O(\log n)\).</p>
<h1 id="discussion">Discussion</h1>
<p>I tested 4 different methods of calculating Fibonacci numbers in hopes of finding the highest \(\mathrm{F_n}\) in under 1 second.
Results largely depended on the algorithm used: the recursive implementation barely calculated the 40th Fibonacci number
while the fast doubling method approached almost 18,000,000!</p>
<p>The figures below show a more direct comparison between algorithms:</p>
<br>
<table style="border-collapse: collapse; text-align: center; margin-inline: auto;">
  <tr>
    <th style="border: 1px solid black; padding: 10px; font-weight: 700;">Algorithm</th>
    <th style="border: 1px solid black; padding: 10px; font-weight: 700;">Highest <i>n</i></th>
    <th style="border: 1px solid black; padding: 10px; font-weight: 700;">Time Complexity</th>
    <th style="border: 1px solid black; padding: 10px; font-weight: 700;">Space Complexity</th>
  </tr>
  <tr>
    <td style="border: 1px solid black; padding: 10px;">Recursive</td>
    <td style="border: 1px solid black; padding: 10px;">38</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #ffcccc;">O(2<sup>n</sup>)</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #fff7cc;">O(n)</td>
  </tr>
  <tr>
    <td style="border: 1px solid black; padding: 10px;">Sliding Win</td>
    <td style="border: 1px solid black; padding: 10px;">694,720</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #fff7cc;">O(n)</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #fff7cc;">O(n)</td>
  </tr>
  <tr>
    <td style="border: 1px solid black; padding: 10px;">Matrix Mult</td>
    <td style="border: 1px solid black; padding: 10px;">4,370,432</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #ccffcc;">O(log n)</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #fff7cc;">O(n)</td>
  </tr>
  <tr>
    <td style="border: 1px solid black; padding: 10px;">Fast Doubl</td>
    <td style="border: 1px solid black; padding: 10px;">17,937,917</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #ccffcc;">O(log n)</td>
    <td style="border: 1px solid black; padding: 10px; background-color: #ccffcc;">O(log n)</td>
  </tr>
</table>
<figure>
  <img src="/images/fibonacci_all.png" alt="All Fibonacci" />
  <figcaption>
    Comparison of runtimes for sliding window, matrix multiplication, and fast doubling Fibonacci.
  </figcaption>
</figure>
<p>I was surprised to find that despite both being \(O(\log n)\) runtime algorithms, matrix multiplication
and fast doubling achieved such drastic iteration differences. I suspect the reason is that fast doubling not only performs fewer <code>BigUint</code>
operations but also takes up less memory. It can therefore benefit more from cache locality and avoid overhead associated with
repeated memory allocations.</p>
<p>This analysis was very preliminary and I'd love to dive deeper into this topic in the future. For example, the <code>BigUint</code> multiplication operations
could be implemented using fast integer multiplication such as <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba</a> or <a href="https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">Schönhage–Strassen</a>.
I could also experiment with other Fibonacci/Lucas number <a href="https://mathworld.wolfram.com/FibonacciNumber.html">identities</a> besides the typical "double-angle" identity.</p>

  </div>


    </main>

    <aside class="layout-right">
      
    </aside>
  </div>

      </div>
    </div>

    <footer class="footer">
       
    </footer>
</body>

</html>
